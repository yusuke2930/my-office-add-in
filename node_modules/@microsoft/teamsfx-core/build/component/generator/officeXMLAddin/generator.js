"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.OfficeXMLAddinGenerator = void 0;
const tslib_1 = require("tslib");
/**
 * @author zyun@microsoft.com
 */
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const childProcess = tslib_1.__importStar(require("child_process"));
const lodash_1 = tslib_1.__importStar(require("lodash"));
const office_addin_manifest_1 = require("office-addin-manifest");
const path_1 = require("path");
const util_1 = require("util");
const localizeUtils_1 = require("../../../common/localizeUtils");
const error_1 = require("../../../error");
const questionNames_1 = require("../../../question/questionNames");
const actionExecutionMW_1 = require("../../middleware/actionExecutionMW");
const generator_1 = require("../generator");
const projectConfig_1 = require("./projectConfig");
const utils_1 = require("../utils");
const utils_2 = require("../../utils");
const COMPONENT_NAME = "office-xml-addin";
const TELEMETRY_EVENT = "generate";
const TEMPLATE_BASE = "office-xml-addin";
const TEMPLATE_COMMON_NAME = "office-xml-addin-common";
const TEMPLATE_COMMON_LANG = "common";
/**
 * project-type=office-xml-addin-type addin-host!==outlook
 */
class OfficeXMLAddinGenerator {
    static async generate(context, inputs, destinationPath, actionContext) {
        const host = inputs[questionNames_1.QuestionNames.OfficeAddinHost];
        const capability = inputs[questionNames_1.QuestionNames.Capabilities];
        const lang = lodash_1.default.toLower(inputs[questionNames_1.QuestionNames.ProgrammingLanguage]);
        const langKey = utils_1.convertToLangKey(lang);
        const appName = inputs[questionNames_1.QuestionNames.AppName];
        const projectType = inputs[questionNames_1.QuestionNames.ProjectType];
        const templateConfig = projectConfig_1.getOfficeAddinTemplateConfig(projectType, host);
        const templateName = templateConfig[capability].localTemplate;
        const projectLink = templateConfig[capability].framework["default"][lang];
        const workingDir = process.cwd();
        const progressBar = context.userInteraction.createProgressBar(localizeUtils_1.getLocalizedString("core.createProjectQuestion.officeXMLAddin.bar.title"), 1);
        lodash_1.merge(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
            ["office-xml-addin-host" /* host */]: host,
            ["office-xml-addin-project" /* project */]: capability,
            ["office-xml-addin-lang" /* lang */]: lang,
        });
        try {
            process.chdir(destinationPath);
            await progressBar.start();
            await progressBar.next(localizeUtils_1.getLocalizedString("core.createProjectQuestion.officeXMLAddin.bar.detail"));
            if (!!projectLink) {
                // [Condition]: Project have remote repo (not manifest-only proj)
                // -> Step: Download the project from GitHub
                const fetchRes = await utils_2.fetchAndUnzip("office-xml-addin-generator", projectLink, destinationPath);
                if (fetchRes.isErr()) {
                    return teamsfx_api_1.err(fetchRes.error);
                }
                // -> Step: Convert to single Host
                await OfficeXMLAddinGenerator.childProcessExec(`npm run convert-to-single-host --if-present -- ${lodash_1.default.toLower(host)}`);
            }
            else {
                // [Condition]: Manifest Only
                // -> Step: Copy proj files for manifest-only project
                const getManifestOnlyProjectTemplateRes = await generator_1.Generator.generateTemplate(context, destinationPath, `${TEMPLATE_BASE}-manifest-only`, langKey);
                if (getManifestOnlyProjectTemplateRes.isErr())
                    throw teamsfx_api_1.err(getManifestOnlyProjectTemplateRes.error);
            }
            // -> Common Step: Copy the README (or with manifest for manifest-only proj)
            const getReadmeTemplateRes = await generator_1.Generator.generateTemplate(context, destinationPath, `${TEMPLATE_BASE}-${templateName}`, langKey);
            if (getReadmeTemplateRes.isErr())
                throw teamsfx_api_1.err(getReadmeTemplateRes.error);
            // -> Common Step: Modify the Manifest
            await office_addin_manifest_1.OfficeAddinManifest.modifyManifestFile(`${path_1.join(destinationPath, "manifest.xml")}`, "random", `${appName}`);
            // -> Common Step: Generate OfficeXMLAddin specific `teamsapp.yml`
            const generateOfficeYMLRes = await generator_1.Generator.generateTemplate(context, destinationPath, TEMPLATE_COMMON_NAME, TEMPLATE_COMMON_LANG);
            if (generateOfficeYMLRes.isErr())
                throw teamsfx_api_1.err(generateOfficeYMLRes.error);
            process.chdir(workingDir);
            await progressBar.end(true, true);
            return teamsfx_api_1.ok(undefined);
        }
        catch (e) {
            process.chdir(workingDir);
            await progressBar.end(false, true);
            return teamsfx_api_1.err(error_1.assembleError(e));
        }
    }
    static async childProcessExec(cmdLine) {
        return util_1.promisify(childProcess.exec)(cmdLine);
    }
}
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: COMPONENT_NAME,
            telemetryEventName: TELEMETRY_EVENT,
            errorSource: COMPONENT_NAME,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], OfficeXMLAddinGenerator, "generate", null);
exports.OfficeXMLAddinGenerator = OfficeXMLAddinGenerator;
//# sourceMappingURL=generator.js.map