"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEnvName = exports.updateForCustomApi = exports.formatValidationErrors = exports.isYamlSpecFile = exports.convertSpecParserErrorToFxError = exports.generateScaffoldingSummary = exports.logValidationResults = exports.listPluginExistingOperations = exports.listOperations = exports.OpenAIPluginManifestHelper = exports.defaultPluginManifestFileName = exports.defaultApiSpecJsonFileName = exports.defaultApiSpecYamlFileName = exports.defaultApiSpecFolderName = exports.invalidApiSpecErrorName = exports.specParserGenerateResultWarningsTelemetryProperty = exports.specParserGenerateResultAllSuccessTelemetryProperty = exports.specParserGenerateResultTelemetryEvent = exports.copilotPluginParserOptions = void 0;
const tslib_1 = require("tslib");
/**
 * @author yuqzho@microsoft.com
 */
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const axios_1 = tslib_1.__importDefault(require("axios"));
const utils_1 = require("../utils");
const m365_spec_parser_1 = require("@microsoft/m365-spec-parser");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const localizeUtils_1 = require("../../../common/localizeUtils");
const error_1 = require("../../../error");
const os_1 = require("os");
const constant_1 = require("../../configManager/constant");
const ManifestUtils_1 = require("../../driver/teamsApp/utils/ManifestUtils");
const path_1 = tslib_1.__importDefault(require("path"));
const questionNames_1 = require("../../../question/questionNames");
const PluginManifestUtils_1 = require("../../driver/teamsApp/utils/PluginManifestUtils");
const constants_1 = require("../../../question/constants");
const question_1 = require("../../../question");
const featureFlags_1 = require("../../../common/featureFlags");
const manifestFilePath = "/.well-known/ai-plugin.json";
const componentName = "OpenAIPluginManifestHelper";
var OpenAIPluginManifestErrorType;
(function (OpenAIPluginManifestErrorType) {
    OpenAIPluginManifestErrorType["AuthNotSupported"] = "openai-pliugin-auth-not-supported";
    OpenAIPluginManifestErrorType["ApiUrlMissing"] = "openai-plugin-api-url-missing";
})(OpenAIPluginManifestErrorType || (OpenAIPluginManifestErrorType = {}));
exports.copilotPluginParserOptions = {
    allowAPIKeyAuth: false,
    allowBearerTokenAuth: featureFlags_1.isCopilotAuthEnabled(),
    allowMultipleParameters: true,
    allowOauth2: featureFlags_1.isCopilotAuthEnabled(),
    projectType: m365_spec_parser_1.ProjectType.Copilot,
    allowMissingId: true,
    allowSwagger: true,
    allowMethods: ["get", "post", "put", "delete", "patch", "head", "connect", "options", "trace"],
    allowResponseSemantics: true,
    allowConversationStarters: true,
    allowConfirmation: true,
};
exports.specParserGenerateResultTelemetryEvent = "spec-parser-generate-result";
exports.specParserGenerateResultAllSuccessTelemetryProperty = "all-success";
exports.specParserGenerateResultWarningsTelemetryProperty = "warnings";
exports.invalidApiSpecErrorName = "invalid-api-spec";
const apiSpecNotUsedInPlugin = "api-spec-not-used-in-plugin";
exports.defaultApiSpecFolderName = "apiSpecificationFile";
exports.defaultApiSpecYamlFileName = "openapi.yaml";
exports.defaultApiSpecJsonFileName = "openapi.json";
exports.defaultPluginManifestFileName = "ai-plugin.json";
class OpenAIPluginManifestHelper {
    static async loadOpenAIPluginManifest(input) {
        input = input.trim();
        let path = input.endsWith("/") ? input.substring(0, input.length - 1) : input;
        if (!input.toLowerCase().endsWith(manifestFilePath)) {
            path = path + manifestFilePath;
        }
        if (!input.toLowerCase().startsWith("https://") && !input.toLowerCase().startsWith("http://")) {
            path = "https://" + path;
        }
        try {
            const res = await utils_1.sendRequestWithRetry(async () => {
                return await axios_1.default.get(path);
            }, 3);
            return res.data;
        }
        catch (e) {
            throw new teamsfx_api_1.UserError(componentName, "loadOpenAIPluginManifest", localizeUtils_1.getLocalizedString("error.copilotPlugin.openAiPluginManifest.CannotGetManifest", path), localizeUtils_1.getLocalizedString("error.copilotPlugin.openAiPluginManifest.CannotGetManifest", path));
        }
    }
    static async updateManifest(openAiPluginManifest, teamsAppManifest, manifestPath) {
        teamsAppManifest.description.full = openAiPluginManifest.description_for_human;
        teamsAppManifest.description.short = openAiPluginManifest.description_for_human;
        teamsAppManifest.developer.websiteUrl = openAiPluginManifest.legal_info_url;
        teamsAppManifest.developer.privacyUrl = openAiPluginManifest.legal_info_url;
        teamsAppManifest.developer.termsOfUseUrl = openAiPluginManifest.legal_info_url;
        await fs_extra_1.default.writeFile(manifestPath, JSON.stringify(teamsAppManifest, null, "\t"), "utf-8");
        return teamsfx_api_1.ok(undefined);
    }
}
exports.OpenAIPluginManifestHelper = OpenAIPluginManifestHelper;
async function listOperations(context, manifest, apiSpecUrl, inputs, includeExistingAPIs = true, shouldLogWarning = true, existingCorrelationId) {
    if (manifest) {
        const errors = validateOpenAIPluginManifest(manifest);
        logValidationResults(errors, [], context, false, shouldLogWarning, false, existingCorrelationId);
        if (errors.length > 0) {
            return teamsfx_api_1.err(errors);
        }
        apiSpecUrl = manifest.api.url;
    }
    const isPlugin = inputs[questionNames_1.QuestionNames.Capabilities] === constants_1.copilotPluginApiSpecOptionId;
    const isCustomApi = inputs[questionNames_1.QuestionNames.CustomCopilotRag] === question_1.CustomCopilotRagOptions.customApi().id;
    try {
        const specParser = new m365_spec_parser_1.SpecParser(apiSpecUrl, isPlugin
            ? exports.copilotPluginParserOptions
            : isCustomApi
                ? {
                    projectType: m365_spec_parser_1.ProjectType.TeamsAi,
                }
                : {
                    allowBearerTokenAuth: true,
                    allowMultipleParameters: true,
                    allowOauth2: featureFlags_1.isCopilotAuthEnabled(),
                });
        const validationRes = await specParser.validate();
        validationRes.errors = formatValidationErrors(validationRes.errors, inputs);
        logValidationResults(validationRes.errors, validationRes.warnings, context, true, shouldLogWarning, false, existingCorrelationId);
        if (validationRes.status === m365_spec_parser_1.ValidationStatus.Error) {
            return teamsfx_api_1.err(validationRes.errors);
        }
        const listResult = await specParser.list();
        let operations = listResult.APIs.filter((value) => value.isValid);
        context.telemetryReporter.sendTelemetryEvent("spec-parser-list-apis-result" /* listApis */, {
            ["valid-apis-count" /* validApisCount */]: listResult.validAPICount.toString(),
            ["all-apis-count" /* allApisCount */]: listResult.allAPICount.toString(),
            ["is-from-adding-api" /* isFromAddingApi */]: (!includeExistingAPIs).toString(),
        });
        // Filter out exsiting APIs
        if (!includeExistingAPIs) {
            const teamsManifestPath = inputs[questionNames_1.QuestionNames.ManifestPath];
            if (!teamsManifestPath) {
                throw new error_1.MissingRequiredInputError("teamsManifestPath", "inputs");
            }
            const manifest = await ManifestUtils_1.manifestUtils._readAppManifest(teamsManifestPath);
            let existingOperations = [];
            if (manifest.isOk()) {
                if (isPlugin) {
                    existingOperations = await listPluginExistingOperations(manifest.value, teamsManifestPath, inputs[questionNames_1.QuestionNames.DestinationApiSpecFilePath]);
                }
                else {
                    const existingOperationIds = ManifestUtils_1.manifestUtils.getOperationIds(manifest.value);
                    existingOperations = operations
                        .filter((operation) => existingOperationIds.includes(operation.operationId))
                        .map((operation) => operation.api);
                }
                operations = operations.filter((operation) => !existingOperations.includes(operation.api));
                // No extra API can be added
                if (operations.length == 0) {
                    const errors = formatValidationErrors([
                        {
                            type: m365_spec_parser_1.ErrorType.NoExtraAPICanBeAdded,
                            content: "",
                        },
                    ], inputs);
                    logValidationResults(errors, [], context, true, false, false, existingCorrelationId);
                    return teamsfx_api_1.err(errors);
                }
            }
            else {
                throw manifest.error;
            }
        }
        const sortedOperations = sortOperations(operations);
        return teamsfx_api_1.ok(sortedOperations);
    }
    catch (e) {
        if (e instanceof m365_spec_parser_1.SpecParserError) {
            throw convertSpecParserErrorToFxError(e);
        }
        else {
            throw e;
        }
    }
}
exports.listOperations = listOperations;
function sortOperations(operations) {
    const operationsWithSeparator = [];
    for (const operation of operations) {
        const arr = operation.api.toUpperCase().split(" ");
        const result = {
            id: operation.api,
            label: operation.api,
            groupName: arr[0],
            detail: !operation.auth
                ? localizeUtils_1.getLocalizedString("core.copilotPlugin.api.noAuth")
                : m365_spec_parser_1.Utils.isBearerTokenAuth(operation.auth.authScheme)
                    ? localizeUtils_1.getLocalizedString("core.copilotPlugin.api.apiKeyAuth")
                    : m365_spec_parser_1.Utils.isOAuthWithAuthCodeFlow(operation.auth.authScheme)
                        ? localizeUtils_1.getLocalizedString("core.copilotPlugin.api.oauth")
                        : "",
            data: {
                serverUrl: operation.server,
            },
        };
        if (operation.auth) {
            if (m365_spec_parser_1.Utils.isBearerTokenAuth(operation.auth.authScheme)) {
                result.data.authType = "apiKey";
                result.data.authName = operation.auth.name;
            }
            else if (m365_spec_parser_1.Utils.isOAuthWithAuthCodeFlow(operation.auth.authScheme)) {
                result.data.authType = "oauth2";
                result.data.authName = operation.auth.name;
            }
        }
        operationsWithSeparator.push(result);
    }
    return operationsWithSeparator.sort((operation1, operation2) => {
        const arr1 = operation1.id.toLowerCase().split(" ");
        const arr2 = operation2.id.toLowerCase().split(" ");
        return arr1[0] < arr2[0] ? -1 : arr1[0] > arr2[0] ? 1 : arr1[1].localeCompare(arr2[1]);
    });
}
function formatTelemetryValidationProperty(result) {
    return result.type.toString();
}
async function listPluginExistingOperations(manifest, teamsManifestPath, destinationApiSpecFilePath) {
    const getApiSPecFileRes = await PluginManifestUtils_1.pluginManifestUtils.getApiSpecFilePathFromTeamsManifest(manifest, teamsManifestPath);
    if (getApiSPecFileRes.isErr()) {
        throw getApiSPecFileRes.error;
    }
    let apiSpecFilePath;
    const apiSpecFiles = getApiSPecFileRes.value;
    for (const file of apiSpecFiles) {
        if (path_1.default.resolve(file) === path_1.default.resolve(destinationApiSpecFilePath)) {
            apiSpecFilePath = file;
            break;
        }
    }
    if (!apiSpecFilePath) {
        throw new teamsfx_api_1.UserError("listPluginExistingOperations", apiSpecNotUsedInPlugin, localizeUtils_1.getLocalizedString("error.copilotPlugin.apiSpecNotUsedInPlugin", destinationApiSpecFilePath), localizeUtils_1.getLocalizedString("error.copilotPlugin.apiSpecNotUsedInPlugin", destinationApiSpecFilePath));
    }
    const specParser = new m365_spec_parser_1.SpecParser(apiSpecFilePath, exports.copilotPluginParserOptions);
    const listResult = await specParser.list();
    return listResult.APIs.map((o) => o.api);
}
exports.listPluginExistingOperations = listPluginExistingOperations;
function logValidationResults(errors, warnings, context, isApiSpec, shouldLogWarning, shouldSkipTelemetry, existingCorrelationId) {
    if (!shouldSkipTelemetry) {
        const properties = {
            ["validation-status" /* validationStatus */]: errors.length !== 0 ? "error" : warnings.length !== 0 ? "warning" : "success",
            ["validation-errors" /* validationErrors */]: errors
                .map((error) => formatTelemetryValidationProperty(error))
                .join(";"),
            ["validation-warnings" /* validationWarnings */]: warnings
                .map((warn) => formatTelemetryValidationProperty(warn))
                .join(";"),
        };
        if (existingCorrelationId) {
            properties["correlation-id"] = existingCorrelationId;
        }
        context.telemetryReporter.sendTelemetryEvent(isApiSpec ? "validate-api-spec" /* validateApiSpec */ : "validate-openai-plugin-manifest" /* validateOpenAiPluginManifest */, properties);
    }
    if (errors.length === 0 && (warnings.length === 0 || !shouldLogWarning)) {
        return;
    }
    // errors > 0 || (warnings > 0 && shouldLogWarning)
    const errorMessage = errors
        .map((error) => {
        return `${constant_1.SummaryConstant.Failed} ${error.content}`;
    })
        .join(os_1.EOL);
    const warningMessage = shouldLogWarning
        ? warnings
            .map((warning) => {
            return `${constant_1.SummaryConstant.NotExecuted} ${warning.content}`;
        })
            .join(os_1.EOL)
        : "";
    const failed = errors.length;
    const warns = warnings.length;
    const summaryStr = [];
    if (failed > 0) {
        summaryStr.push(localizeUtils_1.getLocalizedString("core.copilotPlugin.validate.summary.validate.failed", failed));
    }
    if (warns > 0 && shouldLogWarning) {
        summaryStr.push(localizeUtils_1.getLocalizedString("core.copilotPlugin.validate.summary.validate.warning", warns));
    }
    const outputMessage = isApiSpec
        ? os_1.EOL +
            localizeUtils_1.getLocalizedString("core.copilotPlugin.validate.apiSpec.summary", summaryStr.join(", "), errorMessage, warningMessage)
        : os_1.EOL +
            localizeUtils_1.getLocalizedString("core.copilotPlugin.validate.openAIPluginManifest.summary", summaryStr.join(", "), errorMessage, warningMessage);
    void context.logProvider.info(outputMessage);
}
exports.logValidationResults = logValidationResults;
function validateOpenAIPluginManifest(manifest) {
    var _a, _b;
    const errors = [];
    if (!((_a = manifest.api) === null || _a === void 0 ? void 0 : _a.url)) {
        errors.push({
            type: OpenAIPluginManifestErrorType.ApiUrlMissing,
            content: localizeUtils_1.getLocalizedString("core.createProjectQuestion.openAiPluginManifest.validationError.missingApiUrl", "api.url"),
        });
    }
    if (((_b = manifest.auth) === null || _b === void 0 ? void 0 : _b.type) !== teamsfx_api_1.OpenAIManifestAuthType.None) {
        errors.push({
            type: OpenAIPluginManifestErrorType.AuthNotSupported,
            content: localizeUtils_1.getLocalizedString("core.createProjectQuestion.openAiPluginManifest.validationError.authNotSupported", "none"),
        });
    }
    return errors;
}
function generateScaffoldingSummary(warnings, teamsManifest, apiSpecFilePath) {
    const apiSpecWarningMessage = formatApiSpecValidationWarningMessage(warnings, apiSpecFilePath, teamsManifest);
    const manifestWarningResult = validateTeamsManifestLength(teamsManifest, warnings);
    const manifestWarningMessage = manifestWarningResult.map((warn) => {
        return `${constant_1.SummaryConstant.NotExecuted} ${warn}`;
    });
    if (apiSpecWarningMessage.length || manifestWarningMessage.length) {
        let details = "";
        if (apiSpecWarningMessage.length) {
            details += os_1.EOL + apiSpecWarningMessage.join(os_1.EOL);
        }
        if (manifestWarningMessage.length) {
            details += os_1.EOL + manifestWarningMessage.join(os_1.EOL);
        }
        return localizeUtils_1.getLocalizedString("core.copilotPlugin.scaffold.summary", details);
    }
    else {
        return "";
    }
}
exports.generateScaffoldingSummary = generateScaffoldingSummary;
function formatApiSpecValidationWarningMessage(specWarnings, apiSpecFileName, teamsManifest) {
    const resultWarnings = [];
    const operationIdWarning = specWarnings.find((w) => w.type === m365_spec_parser_1.WarningType.OperationIdMissing);
    if (operationIdWarning) {
        const isApiMe = teamsfx_api_1.ManifestUtil.parseCommonProperties(teamsManifest).isApiME;
        resultWarnings.push(localizeUtils_1.getLocalizedString("core.copilotPlugin.scaffold.summary.warning.operationId", `${constant_1.SummaryConstant.NotExecuted} ${operationIdWarning.content}`, isApiMe ? teamsfx_api_1.ManifestTemplateFileName : apiSpecFileName));
    }
    const swaggerWarning = specWarnings.find((w) => w.type === m365_spec_parser_1.WarningType.ConvertSwaggerToOpenAPI);
    if (swaggerWarning) {
        resultWarnings.push(`${constant_1.SummaryConstant.NotExecuted} ` +
            localizeUtils_1.getLocalizedString("core.copilotPlugin.scaffold.summary.warning.swaggerVersion", apiSpecFileName));
    }
    return resultWarnings;
}
function validateTeamsManifestLength(teamsManifest, warnings) {
    var _a, _b, _c, _d, _e;
    const nameShortLimit = 30;
    const nameFullLimit = 100;
    const descriptionShortLimit = 80;
    const descriptionFullLimit = 4000;
    const appnameSuffixPlaceholder = "${{APP_NAME_SUFFIX}}";
    const devEnv = "dev";
    const resultWarnings = [];
    // validate name
    const shortNameLength = teamsManifest.name.short.includes(appnameSuffixPlaceholder)
        ? teamsManifest.name.short.length - appnameSuffixPlaceholder.length + devEnv.length
        : teamsManifest.name.short.length;
    if (shortNameLength > nameShortLimit) {
        resultWarnings.push(formatLengthExceedingErrorMessage("/name/short", nameShortLimit));
    }
    if (!!teamsManifest.name.full && ((_a = teamsManifest.name.full) === null || _a === void 0 ? void 0 : _a.length) > nameFullLimit) {
        resultWarnings.push(formatLengthExceedingErrorMessage("/name/full", nameFullLimit));
    }
    // validate description
    if (teamsManifest.description.short.length > descriptionShortLimit) {
        resultWarnings.push(formatLengthExceedingErrorMessage("/description/short", descriptionShortLimit));
    }
    if (!((_b = teamsManifest.description.full) === null || _b === void 0 ? void 0 : _b.length)) {
        resultWarnings.push(localizeUtils_1.getLocalizedString("core.copilotPlugin.scaffold.summary.warning.teamsManifest.missingFullDescription") +
            localizeUtils_1.getLocalizedString("core.copilotPlugin.scaffold.summary.warning.teamsManifest.mitigation", "full/description", path_1.default.join(teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ManifestTemplateFileName)));
    }
    if (teamsManifest.description.full.length > descriptionFullLimit) {
        resultWarnings.push(formatLengthExceedingErrorMessage("/description/full", descriptionFullLimit));
    }
    // validate command
    if (teamsfx_api_1.ManifestUtil.parseCommonProperties(teamsManifest).isApiME) {
        const optionalParamsOnlyWarnings = warnings.filter((o) => o.type === m365_spec_parser_1.WarningType.OperationOnlyContainsOptionalParam);
        const commands = teamsManifest.composeExtensions[0].commands;
        if (optionalParamsOnlyWarnings) {
            for (const optionalParamsOnlyWarning of optionalParamsOnlyWarnings) {
                const command = commands.find((o) => o.id === optionalParamsOnlyWarning.data);
                if (command && command.parameters) {
                    const parameterName = (_c = command.parameters[0]) === null || _c === void 0 ? void 0 : _c.name;
                    resultWarnings.push(localizeUtils_1.getLocalizedString("core.copilotPlugin.scaffold.summary.warning.api.optionalParametersOnly", optionalParamsOnlyWarning.data, optionalParamsOnlyWarning.data) +
                        localizeUtils_1.getLocalizedString("core.copilotPlugin.scaffold.summary.warning.api.optionalParametersOnly.mitigation", parameterName, optionalParamsOnlyWarning.data, path_1.default.join(teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ManifestTemplateFileName), path_1.default.join(teamsfx_api_1.AppPackageFolderName, (_d = teamsManifest.composeExtensions[0].apiSpecificationFile) !== null && _d !== void 0 ? _d : "")));
                }
            }
        }
        for (const command of commands) {
            if (command.type === "query") {
                if (!command.apiResponseRenderingTemplateFile) {
                    const errorDetail = (_e = warnings.find((w) => w.type === m365_spec_parser_1.WarningType.GenerateCardFailed && w.data === command.id)) === null || _e === void 0 ? void 0 : _e.content;
                    resultWarnings.push(localizeUtils_1.getLocalizedString("core.copilotPlugin.scaffold.summary.warning.teamsManifest.missingCardTemlate", "apiResponseRenderingTemplateFile", command.id) +
                        localizeUtils_1.getLocalizedString("core.copilotPlugin.scaffold.summary.warning.teamsManifest.missingCardTemlate.mitigation", teamsfx_api_1.AppPackageFolderName, `composeExtensions/commands/${command.id}/apiResponseRenderingTemplateFile`, path_1.default.join(teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ManifestTemplateFileName)) +
                        (errorDetail ? os_1.EOL + errorDetail : ""));
                }
            }
        }
    }
    return resultWarnings;
}
function formatLengthExceedingErrorMessage(field, limit) {
    return (localizeUtils_1.getLocalizedString("core.copilotPlugin.scaffold.summary.warning.teamsManifest.lengthExceeding", field, limit.toString()) +
        localizeUtils_1.getLocalizedString("core.copilotPlugin.scaffold.summary.warning.teamsManifest.mitigation", field, path_1.default.join(teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ManifestTemplateFileName)));
}
function convertSpecParserErrorToFxError(error) {
    return new teamsfx_api_1.SystemError("SpecParser", error.errorType.toString(), error.message, error.message);
}
exports.convertSpecParserErrorToFxError = convertSpecParserErrorToFxError;
async function isYamlSpecFile(specPath) {
    if (specPath.endsWith(".yaml") || specPath.endsWith(".yml")) {
        return true;
    }
    else if (specPath.endsWith(".json")) {
        return false;
    }
    const isRemoteFile = specPath.startsWith("http:") || specPath.startsWith("https:");
    const fileContent = isRemoteFile
        ? (await axios_1.default.get(specPath)).data
        : await fs_extra_1.default.readFile(specPath, "utf-8");
    try {
        JSON.parse(fileContent);
        return false;
    }
    catch (error) {
        return true;
    }
}
exports.isYamlSpecFile = isYamlSpecFile;
function formatValidationErrors(errors, inputs) {
    return errors.map((error) => {
        return {
            type: error.type,
            content: formatValidationErrorContent(error, inputs),
            data: error.data,
        };
    });
}
exports.formatValidationErrors = formatValidationErrors;
function mapInvalidReasonToMessage(reason) {
    switch (reason) {
        case m365_spec_parser_1.ErrorType.AuthTypeIsNotSupported:
            return localizeUtils_1.getLocalizedString("core.common.invalidReason.AuthTypeIsNotSupported");
        case m365_spec_parser_1.ErrorType.MissingOperationId:
            return localizeUtils_1.getLocalizedString("core.common.invalidReason.MissingOperationId");
        case m365_spec_parser_1.ErrorType.PostBodyContainMultipleMediaTypes:
            return localizeUtils_1.getLocalizedString("core.common.invalidReason.PostBodyContainMultipleMediaTypes");
        case m365_spec_parser_1.ErrorType.ResponseContainMultipleMediaTypes:
            return localizeUtils_1.getLocalizedString("core.common.invalidReason.ResponseContainMultipleMediaTypes");
        case m365_spec_parser_1.ErrorType.ResponseJsonIsEmpty:
            return localizeUtils_1.getLocalizedString("core.common.invalidReason.ResponseJsonIsEmpty");
        case m365_spec_parser_1.ErrorType.PostBodySchemaIsNotJson:
            return localizeUtils_1.getLocalizedString("core.common.invalidReason.PostBodySchemaIsNotJson");
        case m365_spec_parser_1.ErrorType.PostBodyContainsRequiredUnsupportedSchema:
            return localizeUtils_1.getLocalizedString("core.common.invalidReason.PostBodyContainsRequiredUnsupportedSchema");
        case m365_spec_parser_1.ErrorType.ParamsContainRequiredUnsupportedSchema:
            return localizeUtils_1.getLocalizedString("core.common.invalidReason.ParamsContainRequiredUnsupportedSchema");
        case m365_spec_parser_1.ErrorType.ParamsContainsNestedObject:
            return localizeUtils_1.getLocalizedString("core.common.invalidReason.ParamsContainsNestedObject");
        case m365_spec_parser_1.ErrorType.RequestBodyContainsNestedObject:
            return localizeUtils_1.getLocalizedString("core.common.invalidReason.RequestBodyContainsNestedObject");
        case m365_spec_parser_1.ErrorType.ExceededRequiredParamsLimit:
            return localizeUtils_1.getLocalizedString("core.common.invalidReason.ExceededRequiredParamsLimit");
        case m365_spec_parser_1.ErrorType.NoParameter:
            return localizeUtils_1.getLocalizedString("core.common.invalidReason.NoParameter");
        case m365_spec_parser_1.ErrorType.NoAPIInfo:
            return localizeUtils_1.getLocalizedString("core.common.invalidReason.NoAPIInfo");
        case m365_spec_parser_1.ErrorType.MethodNotAllowed:
            return localizeUtils_1.getLocalizedString("core.common.invalidReason.MethodNotAllowed");
        case m365_spec_parser_1.ErrorType.UrlPathNotExist:
            return localizeUtils_1.getLocalizedString("core.common.invalidReason.UrlPathNotExist");
        default:
            return reason.toString();
    }
}
function formatValidationErrorContent(error, inputs) {
    const isPlugin = inputs[questionNames_1.QuestionNames.Capabilities] === constants_1.copilotPluginApiSpecOptionId;
    try {
        switch (error.type) {
            case m365_spec_parser_1.ErrorType.SpecNotValid: {
                let content = error.content;
                if (error.content.startsWith("ResolverError: Error downloading")) {
                    content = error.content
                        .split("\n")
                        .map((o) => o.trim())
                        .join(". ");
                    content = `${content}. ${localizeUtils_1.getLocalizedString("core.common.ErrorFetchApiSpec")}`;
                }
                else if (error.content.startsWith("RangeError: Maximum call stack size exceeded")) {
                    content = localizeUtils_1.getLocalizedString("core.common.CircularReferenceNotSupported");
                }
                return content;
            }
            case m365_spec_parser_1.ErrorType.RemoteRefNotSupported:
                return localizeUtils_1.getLocalizedString("core.common.RemoteRefNotSupported", error.data.join(", "));
            case m365_spec_parser_1.ErrorType.NoServerInformation:
                return localizeUtils_1.getLocalizedString("core.common.NoServerInformation");
            case m365_spec_parser_1.ErrorType.UrlProtocolNotSupported:
                return localizeUtils_1.getLocalizedString("core.common.UrlProtocolNotSupported", error.data);
            case m365_spec_parser_1.ErrorType.RelativeServerUrlNotSupported:
                return localizeUtils_1.getLocalizedString("core.common.RelativeServerUrlNotSupported");
            case m365_spec_parser_1.ErrorType.NoSupportedApi:
                const messages = [];
                const invalidAPIInfo = error.data;
                for (const info of invalidAPIInfo) {
                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                    const mes = `${info.api}: ${info.reason.map(mapInvalidReasonToMessage).join(", ")}`;
                    messages.push(mes);
                }
                if (messages.length === 0) {
                    messages.push(localizeUtils_1.getLocalizedString("core.common.invalidReason.NoAPIs"));
                }
                return isPlugin
                    ? localizeUtils_1.getLocalizedString("core.common.NoSupportedApiCopilot", messages.join("\n"))
                    : localizeUtils_1.getLocalizedString("core.common.NoSupportedApi", messages.join("\n"));
            case m365_spec_parser_1.ErrorType.NoExtraAPICanBeAdded:
                return isPlugin
                    ? localizeUtils_1.getLocalizedString("error.copilot.noExtraAPICanBeAdded")
                    : localizeUtils_1.getLocalizedString("error.apime.noExtraAPICanBeAdded");
            case m365_spec_parser_1.ErrorType.ResolveServerUrlFailed:
                return error.content;
            case m365_spec_parser_1.ErrorType.Cancelled:
                return localizeUtils_1.getLocalizedString("core.common.CancelledMessage");
            case m365_spec_parser_1.ErrorType.SwaggerNotSupported:
                return localizeUtils_1.getLocalizedString("core.common.SwaggerNotSupported");
            case m365_spec_parser_1.ErrorType.SpecVersionNotSupported:
                return localizeUtils_1.getLocalizedString("core.common.SpecVersionNotSupported", error.data);
            default:
                return error.content;
        }
    }
    catch (e) {
        return error.content;
    }
}
function parseSpec(spec) {
    const res = [];
    let needAuth = false;
    const paths = spec.paths;
    if (paths) {
        for (const pathUrl in paths) {
            const pathItem = paths[pathUrl];
            if (pathItem) {
                const operations = pathItem;
                for (const method in operations) {
                    if (method === "get" || method === "post") {
                        const operationItem = operations[method];
                        if (operationItem) {
                            const authResult = m365_spec_parser_1.Utils.getAuthArray(operationItem.security, spec);
                            const hasAuth = authResult.length != 0;
                            if (hasAuth) {
                                needAuth = true;
                            }
                            res.push({
                                item: operationItem,
                                method: method,
                                pathUrl: pathUrl,
                                auth: hasAuth,
                            });
                        }
                    }
                }
            }
        }
    }
    return [res, needAuth];
}
async function updatePromptForCustomApi(spec, language, chatFolder) {
    if (language === question_1.ProgrammingLanguage.JS || language === question_1.ProgrammingLanguage.TS) {
        const promptFilePath = path_1.default.join(chatFolder, "skprompt.txt");
        const prompt = `The following is a conversation with an AI assistant.\nThe assistant can help to call APIs for the open api spec file${spec.info.description ? ". " + spec.info.description : "."}\nIf the API doesn't require parameters, invoke it with default JSON object { "path": null, "body": null, "query": null }.\n\ncontext:\nAvailable actions: {{getAction}}.`;
        await fs_extra_1.default.writeFile(promptFilePath, prompt, { encoding: "utf-8", flag: "w" });
    }
}
async function updateAdaptiveCardForCustomApi(specItems, language, destinationPath) {
    if (language === question_1.ProgrammingLanguage.JS || language === question_1.ProgrammingLanguage.TS) {
        const adaptiveCardsFolderPath = path_1.default.join(destinationPath, "src", "adaptiveCards");
        await fs_extra_1.default.ensureDir(adaptiveCardsFolderPath);
        for (const item of specItems) {
            const name = item.item.operationId;
            const [card] = m365_spec_parser_1.AdaptiveCardGenerator.generateAdaptiveCard(item.item);
            const cardFilePath = path_1.default.join(adaptiveCardsFolderPath, `${name}.json`);
            await fs_extra_1.default.writeFile(cardFilePath, JSON.stringify(card, null, 2));
        }
    }
}
async function updateActionForCustomApi(specItems, language, chatFolder) {
    var _a, _b;
    if (language === question_1.ProgrammingLanguage.JS || language === question_1.ProgrammingLanguage.TS) {
        const actionsFilePath = path_1.default.join(chatFolder, "actions.json");
        const actions = [];
        for (const item of specItems) {
            const parameters = {
                type: "object",
                properties: {},
                required: [],
            };
            const paramObject = item.item.parameters;
            if (paramObject) {
                for (let i = 0; i < paramObject.length; i++) {
                    const param = paramObject[i];
                    const schema = param.schema;
                    const paramType = param.in;
                    if (!parameters.properties[paramType]) {
                        parameters.properties[paramType] = {
                            type: "object",
                            properties: {},
                            required: [],
                        };
                    }
                    parameters.properties[paramType].properties[param.name] = schema;
                    parameters.properties[paramType].properties[param.name].description =
                        (_a = param.description) !== null && _a !== void 0 ? _a : "";
                    if (param.required) {
                        parameters.properties[paramType].required.push(param.name);
                        if (!parameters.required.includes(paramType)) {
                            parameters.required.push(paramType);
                        }
                    }
                }
            }
            actions.push({
                name: item.item.operationId,
                description: (_b = item.item.description) !== null && _b !== void 0 ? _b : item.item.summary,
                parameters: parameters,
            });
        }
        await fs_extra_1.default.writeFile(actionsFilePath, JSON.stringify(actions, null, 2));
    }
}
const ActionCode = {
    javascript: `
app.ai.action("{{operationId}}", async (context, state, parameter) => {
  const client = await api.getClient();
  // Add authentication configuration for the client
  const path = client.paths["{{pathUrl}}"];
  if (path && path.{{method}}) {
    const result = await path.{{method}}(parameter.path, parameter.body, {
      params: parameter.query,
    });
    const card = generateAdaptiveCard("../adaptiveCards/{{operationId}}.json", result);
    await context.sendActivity({ attachments: [card] });
  } else {
    await context.sendActivity("no result");
  }
  return "result";
});
  `,
    typescript: `
app.ai.action("{{operationId}}", async (context: TurnContext, state: ApplicationTurnState, parameter: any) => {
  const client = await api.getClient();
  // Add authentication configuration for the client
  const path = client.paths["{{pathUrl}}"];
  if (path && path.{{method}}) {
    const result = await path.{{method}}(parameter.path, parameter.body, {
      params: parameter.query,
    });
    const card = generateAdaptiveCard("../adaptiveCards/{{operationId}}.json", result);
    await context.sendActivity({ attachments: [card] });
  } else {
    await context.sendActivity("no result");
  }
  return "result";
});
  `,
};
const AuthCode = {
    javascript: {
        actionCode: `addAuthConfig(client);`,
        actionPlaceholder: `// Add authentication configuration for the client`,
    },
    typescript: {
        actionCode: `addAuthConfig(client);`,
        actionPlaceholder: `// Add authentication configuration for the client`,
    },
};
async function updateCodeForCustomApi(specItems, language, destinationPath, openapiSpecFileName, needAuth) {
    if (language === question_1.ProgrammingLanguage.JS || language === question_1.ProgrammingLanguage.TS) {
        const codeTemplate = ActionCode[language === question_1.ProgrammingLanguage.JS ? "javascript" : "typescript"];
        const appFolderPath = path_1.default.join(destinationPath, "src", "app");
        const actionsCode = [];
        const authCodeTemplate = AuthCode[language === question_1.ProgrammingLanguage.JS ? "javascript" : "typescript"];
        for (const item of specItems) {
            const auth = item.auth;
            const code = codeTemplate
                .replace(authCodeTemplate.actionPlaceholder, auth ? authCodeTemplate.actionCode : "")
                .replace(/{{operationId}}/g, item.item.operationId)
                .replace(/{{pathUrl}}/g, item.pathUrl)
                .replace(/{{method}}/g, item.method);
            actionsCode.push(code);
        }
        // Update code in app file
        const indexFilePath = path_1.default.join(appFolderPath, language === question_1.ProgrammingLanguage.JS ? "app.js" : "app.ts");
        const indexFileContent = (await fs_extra_1.default.readFile(indexFilePath)).toString();
        const updateIndexFileContent = indexFileContent
            .replace("{{OPENAPI_SPEC_PATH}}", openapiSpecFileName)
            .replace("// Replace with action code", actionsCode.join("\n"));
        await fs_extra_1.default.writeFile(indexFilePath, updateIndexFileContent);
    }
}
async function updateForCustomApi(spec, language, destinationPath, openapiSpecFileName) {
    const chatFolder = path_1.default.join(destinationPath, "src", "prompts", "chat");
    await fs_extra_1.default.ensureDir(chatFolder);
    // 1. update prompt folder
    await updatePromptForCustomApi(spec, language, chatFolder);
    const [specItems, needAuth] = parseSpec(spec);
    // 2. update adaptive card folder
    await updateAdaptiveCardForCustomApi(specItems, language, destinationPath);
    // 3. update actions file
    await updateActionForCustomApi(specItems, language, chatFolder);
    // 4. update code
    await updateCodeForCustomApi(specItems, language, destinationPath, openapiSpecFileName, needAuth);
}
exports.updateForCustomApi = updateForCustomApi;
const EnvNameMapping = {
    apiKey: "REGISTRATION_ID",
    oauth2: "CONFIGURATION_ID",
};
function getEnvName(authName, authType) {
    return m365_spec_parser_1.Utils.getSafeRegistrationIdEnvName(`${authName}_${EnvNameMapping[authType !== null && authType !== void 0 ? authType : "apiKey"]}`);
}
exports.getEnvName = getEnvName;
//# sourceMappingURL=helper.js.map