"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.CopilotPluginGenerator = void 0;
const tslib_1 = require("tslib");
/**
 * @author yuqzho@microsoft.com
 */
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const generator_1 = require("../generator");
const path_1 = tslib_1.__importDefault(require("path"));
const actionExecutionMW_1 = require("../../middleware/actionExecutionMW");
const telemetryEvents_1 = require("../spfx/utils/telemetryEvents");
const questionNames_1 = require("../../../question/questionNames");
const helper_1 = require("./helper");
const localizeUtils_1 = require("../../../common/localizeUtils");
const ManifestUtils_1 = require("../../driver/teamsApp/utils/ManifestUtils");
const create_1 = require("../../../question/create");
const fs = tslib_1.__importStar(require("fs-extra"));
const error_1 = require("../../../error");
const m365_spec_parser_1 = require("@microsoft/m365-spec-parser");
const util = tslib_1.__importStar(require("util"));
const util_1 = require("../../../question/util");
const lodash_1 = require("lodash");
const featureFlags_1 = require("../../../common/featureFlags");
const fromApiSpecComponentName = "copilot-plugin-existing-api";
const pluginFromApiSpecComponentName = "api-copilot-plugin-existing-api";
const fromApiSpecTemplateName = "copilot-plugin-existing-api";
const fromApiSpecWithApiKeyTemplateName = "copilot-plugin-existing-api-api-key";
const fromOpenAIPlugincomponentName = "copilot-plugin-from-oai-plugin";
const fromOpenAIPluginTemplateName = "copilot-plugin-from-oai-plugin";
const forCustomCopilotRagCustomApi = "custom-copilot-rag-custom-api";
const copilotPluginExistingApiSpecUrlTelemetryEvent = "copilot-plugin-existing-api-spec-url";
const apiPluginFromApiSpecTemplateName = "api-plugin-existing-api";
const failedToUpdateCustomApiTemplateErrorName = "failed-to-update-custom-api-template";
function normalizePath(path) {
    return "./" + path.replace(/\\/g, "/");
}
class CopilotPluginGenerator {
    static async generateMeFromApiSpec(context, inputs, destinationPath, actionContext) {
        const templateName = fromApiSpecTemplateName;
        const componentName = fromApiSpecComponentName;
        lodash_1.merge(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, { ["template-name" /* templateName */]: templateName });
        return await this.generate(context, inputs, destinationPath, templateName, componentName, false, inputs.apiAuthData);
    }
    static async generatePluginFromApiSpec(context, inputs, destinationPath, actionContext) {
        const templateName = apiPluginFromApiSpecTemplateName;
        const componentName = fromApiSpecComponentName;
        lodash_1.merge(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, { ["template-name" /* templateName */]: templateName });
        return await this.generate(context, inputs, destinationPath, templateName, componentName, true, inputs.apiAuthData);
    }
    static async generateFromOpenAIPlugin(context, inputs, destinationPath) {
        return await this.generate(context, inputs, destinationPath, fromOpenAIPluginTemplateName, fromOpenAIPlugincomponentName, false);
    }
    static async generateForCustomCopilotRagCustomApi(context, inputs, destinationPath) {
        return await this.generate(context, inputs, destinationPath, forCustomCopilotRagCustomApi, forCustomCopilotRagCustomApi, false);
    }
    static async generate(context, inputs, destinationPath, templateName, componentName, isPlugin, authData) {
        var _a, _b, _c;
        try {
            const appName = inputs[questionNames_1.QuestionNames.AppName];
            const language = inputs[questionNames_1.QuestionNames.ProgrammingLanguage];
            const safeProjectNameFromVS = language === "csharp" ? inputs[questionNames_1.QuestionNames.SafeProjectName] : undefined;
            const type = templateName === forCustomCopilotRagCustomApi
                ? m365_spec_parser_1.ProjectType.TeamsAi
                : isPlugin
                    ? m365_spec_parser_1.ProjectType.Copilot
                    : m365_spec_parser_1.ProjectType.SME;
            const manifestPath = path_1.default.join(destinationPath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ManifestTemplateFileName);
            const apiSpecFolderPath = path_1.default.join(destinationPath, teamsfx_api_1.AppPackageFolderName, helper_1.defaultApiSpecFolderName);
            let url = (_a = inputs[questionNames_1.QuestionNames.ApiSpecLocation]) !== null && _a !== void 0 ? _a : (_b = inputs.openAIPluginManifest) === null || _b === void 0 ? void 0 : _b.api.url;
            url = url.trim();
            let isYaml;
            try {
                isYaml = await helper_1.isYamlSpecFile(url);
            }
            catch (e) {
                isYaml = false;
            }
            const openapiSpecFileName = isYaml ? helper_1.defaultApiSpecYamlFileName : helper_1.defaultApiSpecJsonFileName;
            const openapiSpecPath = path_1.default.join(apiSpecFolderPath, openapiSpecFileName);
            if (authData === null || authData === void 0 ? void 0 : authData.authName) {
                const envName = helper_1.getEnvName(authData.authName, authData.authType);
                context.templateVariables = generator_1.Generator.getDefaultVariables(appName, safeProjectNameFromVS, inputs.targetFramework, inputs.placeProjectFileInSolutionDir === "true", {
                    authName: authData.authName,
                    openapiSpecPath: normalizePath(path_1.default.join(teamsfx_api_1.AppPackageFolderName, helper_1.defaultApiSpecFolderName, openapiSpecFileName)),
                    registrationIdEnvName: envName,
                    authType: authData.authType,
                });
            }
            else {
                context.templateVariables = generator_1.Generator.getDefaultVariables(appName, safeProjectNameFromVS, inputs.targetFramework, inputs.placeProjectFileInSolutionDir === "true");
            }
            const filters = inputs[questionNames_1.QuestionNames.ApiOperation];
            if (templateName != forCustomCopilotRagCustomApi) {
                // download template
                const templateRes = await generator_1.Generator.generateTemplate(context, destinationPath, templateName, language === create_1.ProgrammingLanguage.CSharp ? create_1.ProgrammingLanguage.CSharp : undefined);
                if (templateRes.isErr())
                    return teamsfx_api_1.err(templateRes.error);
            }
            context.telemetryReporter.sendTelemetryEvent(copilotPluginExistingApiSpecUrlTelemetryEvent, {
                ["remote-url" /* isRemoteUrlTelemetryProperty */]: util_1.isValidHttpUrl(url).toString(),
                ["generate-type" /* generateType */]: type.toString(),
                ["auth-type" /* authType */]: (_c = authData === null || authData === void 0 ? void 0 : authData.authName) !== null && _c !== void 0 ? _c : "None",
            });
            // validate API spec
            const specParser = new m365_spec_parser_1.SpecParser(url, isPlugin
                ? helper_1.copilotPluginParserOptions
                : {
                    allowBearerTokenAuth: true,
                    allowMultipleParameters: true,
                    projectType: type,
                    allowOauth2: featureFlags_1.isCopilotAuthEnabled(),
                });
            const validationRes = await specParser.validate();
            const warnings = validationRes.warnings;
            const operationIdWarning = warnings.find((w) => w.type === m365_spec_parser_1.WarningType.OperationIdMissing);
            if (operationIdWarning && operationIdWarning.data) {
                const apisMissingOperationId = operationIdWarning.data.filter((api) => filters.includes(api));
                if (apisMissingOperationId.length > 0) {
                    operationIdWarning.content = util.format(localizeUtils_1.getLocalizedString("core.common.MissingOperationId"), apisMissingOperationId.join(", "));
                    delete operationIdWarning.data;
                }
                else {
                    warnings.splice(warnings.indexOf(operationIdWarning), 1);
                }
            }
            const specVersionWarning = warnings.find((w) => w.type === m365_spec_parser_1.WarningType.ConvertSwaggerToOpenAPI);
            if (specVersionWarning) {
                specVersionWarning.content = ""; // We don't care content of this warning
            }
            if (validationRes.status === m365_spec_parser_1.ValidationStatus.Error) {
                helper_1.logValidationResults(validationRes.errors, warnings, context, true, false, true);
                const errorMessage = inputs.platform === teamsfx_api_1.Platform.VSCode
                    ? localizeUtils_1.getLocalizedString("core.createProjectQuestion.apiSpec.multipleValidationErrors.vscode.message")
                    : localizeUtils_1.getLocalizedString("core.createProjectQuestion.apiSpec.multipleValidationErrors.message");
                return teamsfx_api_1.err(new teamsfx_api_1.UserError(componentName, helper_1.invalidApiSpecErrorName, errorMessage, errorMessage));
            }
            // generate files
            await fs.ensureDir(apiSpecFolderPath);
            let generateResult;
            if (isPlugin) {
                const pluginManifestPath = path_1.default.join(destinationPath, teamsfx_api_1.AppPackageFolderName, helper_1.defaultPluginManifestFileName);
                generateResult = await specParser.generateForCopilot(manifestPath, filters, openapiSpecPath, pluginManifestPath);
            }
            else {
                const responseTemplateFolder = path_1.default.join(destinationPath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ResponseTemplatesFolderName);
                generateResult = await specParser.generate(manifestPath, filters, openapiSpecPath, type === m365_spec_parser_1.ProjectType.TeamsAi ? undefined : responseTemplateFolder);
            }
            context.telemetryReporter.sendTelemetryEvent(helper_1.specParserGenerateResultTelemetryEvent, {
                ["generate-type" /* generateType */]: type.toString(),
                [helper_1.specParserGenerateResultAllSuccessTelemetryProperty]: generateResult.allSuccess.toString(),
                [helper_1.specParserGenerateResultWarningsTelemetryProperty]: generateResult.warnings
                    .map((w) => w.type.toString() + ": " + w.content)
                    .join(";"),
            });
            if (generateResult.warnings.length > 0) {
                generateResult.warnings.find((o) => {
                    if (o.type === m365_spec_parser_1.WarningType.OperationOnlyContainsOptionalParam) {
                        o.content = ""; // We don't care content of this warning
                    }
                });
                warnings.push(...generateResult.warnings);
            }
            // update manifest based on openAI plugin manifest
            const manifestRes = await ManifestUtils_1.manifestUtils._readAppManifest(manifestPath);
            if (manifestRes.isErr()) {
                return teamsfx_api_1.err(manifestRes.error);
            }
            const teamsManifest = manifestRes.value;
            if (inputs.openAIPluginManifest) {
                const updateManifestRes = await helper_1.OpenAIPluginManifestHelper.updateManifest(inputs.openAIPluginManifest, teamsManifest, manifestPath);
                if (updateManifestRes.isErr())
                    return teamsfx_api_1.err(updateManifestRes.error);
            }
            if (componentName === forCustomCopilotRagCustomApi) {
                const specs = await specParser.getFilteredSpecs(filters);
                const spec = specs[1];
                try {
                    await helper_1.updateForCustomApi(spec, language, destinationPath, openapiSpecFileName);
                }
                catch (error) {
                    throw new teamsfx_api_1.SystemError(componentName, failedToUpdateCustomApiTemplateErrorName, error.message, error.message);
                }
            }
            // log warnings
            if (inputs.platform === teamsfx_api_1.Platform.CLI || inputs.platform === teamsfx_api_1.Platform.VS) {
                const warnSummary = helper_1.generateScaffoldingSummary(warnings, teamsManifest, path_1.default.relative(destinationPath, openapiSpecPath));
                if (warnSummary) {
                    void context.logProvider.info(warnSummary);
                }
            }
            if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
                return teamsfx_api_1.ok({
                    warnings: warnings.map((warning) => {
                        return {
                            type: warning.type,
                            content: warning.content,
                            data: warning.data,
                        };
                    }),
                });
            }
            else {
                return teamsfx_api_1.ok({ warnings: undefined });
            }
        }
        catch (e) {
            let error;
            if (e instanceof m365_spec_parser_1.SpecParserError) {
                error = helper_1.convertSpecParserErrorToFxError(e);
            }
            else {
                error = error_1.assembleError(e);
            }
            return teamsfx_api_1.err(error);
        }
    }
}
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: fromApiSpecComponentName,
            telemetryEventName: telemetryEvents_1.TelemetryEvents.Generate,
            errorSource: fromApiSpecComponentName,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], CopilotPluginGenerator, "generateMeFromApiSpec", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: pluginFromApiSpecComponentName,
            telemetryEventName: telemetryEvents_1.TelemetryEvents.Generate,
            errorSource: pluginFromApiSpecComponentName,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], CopilotPluginGenerator, "generatePluginFromApiSpec", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: fromOpenAIPlugincomponentName,
            telemetryEventName: telemetryEvents_1.TelemetryEvents.Generate,
            errorSource: fromOpenAIPlugincomponentName,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, String]),
    tslib_1.__metadata("design:returntype", Promise)
], CopilotPluginGenerator, "generateFromOpenAIPlugin", null);
tslib_1.__decorate([
    lib_1.hooks([
        actionExecutionMW_1.ActionExecutionMW({
            enableTelemetry: true,
            telemetryComponentName: fromOpenAIPlugincomponentName,
            telemetryEventName: telemetryEvents_1.TelemetryEvents.Generate,
            errorSource: fromOpenAIPlugincomponentName,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, String]),
    tslib_1.__metadata("design:returntype", Promise)
], CopilotPluginGenerator, "generateForCustomCopilotRagCustomApi", null);
exports.CopilotPluginGenerator = CopilotPluginGenerator;
//# sourceMappingURL=generator.js.map