"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.copilotGptManifestUtils = exports.CopilotGptManifestUtils = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const common_1 = require("../../../../error/common");
const strip_bom_1 = tslib_1.__importDefault(require("strip-bom"));
const telemetry_1 = require("./telemetry");
const utils_1 = require("./utils");
const results_1 = require("../results");
const errors_1 = require("../errors");
const localizeUtils_1 = require("../../../../common/localizeUtils");
const path_1 = tslib_1.__importDefault(require("path"));
const PluginManifestUtils_1 = require("./PluginManifestUtils");
const constant_1 = require("../../../configManager/constant");
const os_1 = require("os");
class CopilotGptManifestUtils {
    async readCopilotGptManifestFile(path) {
        if (!(await fs_extra_1.default.pathExists(path))) {
            return teamsfx_api_1.err(new common_1.FileNotFoundError("CopilotGptManifestUtils", path));
        }
        // Be compatible with UTF8-BOM encoding
        // Avoid Unexpected token error at JSON.parse()
        let content = await fs_extra_1.default.readFile(path, { encoding: "utf-8" });
        content = strip_bom_1.default(content);
        try {
            const manifest = JSON.parse(content);
            return teamsfx_api_1.ok(manifest);
        }
        catch (e) {
            return teamsfx_api_1.err(new common_1.JSONSyntaxError(path, e, "CopilotGptManifestUtils"));
        }
    }
    /**
     * Get Declarative Copilot Manifest with env value filled.
     * @param path path of declaraitve Copilot
     * @returns resolved manifest
     */
    async getManifest(path, context) {
        const manifestRes = await this.readCopilotGptManifestFile(path);
        if (manifestRes.isErr()) {
            return teamsfx_api_1.err(manifestRes.error);
        }
        // Add environment variable keys to telemetry
        const resolvedManifestRes = utils_1.getResolvedManifest(JSON.stringify(manifestRes.value), path, telemetry_1.TelemetryPropertyKey.customizedCopilotGptKeys, context);
        if (resolvedManifestRes.isErr()) {
            return teamsfx_api_1.err(resolvedManifestRes.error);
        }
        const resolvedManifestString = resolvedManifestRes.value;
        return teamsfx_api_1.ok(JSON.parse(resolvedManifestString));
    }
    async writeCopilotGptManifestFile(manifest, path) {
        const content = JSON.stringify(manifest, undefined, 4);
        try {
            await fs_extra_1.default.writeFile(path, content);
        }
        catch (e) {
            return teamsfx_api_1.err(new common_1.WriteFileError(e, "copilotGptManifestUtils"));
        }
        return teamsfx_api_1.ok(undefined);
    }
    async validateAgainstSchema(declaraitveCopilot, manifestPath, context) {
        var _a;
        const manifestRes = await this.getManifest(manifestPath, context);
        if (manifestRes.isErr()) {
            return teamsfx_api_1.err(manifestRes.error);
        }
        const manifest = manifestRes.value;
        try {
            const manifestValidationRes = await teamsfx_api_1.ManifestUtil.validateManifest(manifestRes.value);
            const res = {
                id: declaraitveCopilot.id,
                filePath: manifestPath,
                validationResult: manifestValidationRes,
                actionValidationResult: [],
            };
            if ((_a = manifest.actions) === null || _a === void 0 ? void 0 : _a.length) {
                // action
                for (const action of manifest.actions) {
                    const actionPath = path_1.default.join(path_1.default.dirname(manifestPath), action.file);
                    const actionValidationRes = await PluginManifestUtils_1.pluginManifestUtils.validateAgainstSchema(action, actionPath, context);
                    if (actionValidationRes.isErr()) {
                        return teamsfx_api_1.err(actionValidationRes.error);
                    }
                    else {
                        res.actionValidationResult.push(actionValidationRes.value);
                    }
                }
            }
            return teamsfx_api_1.ok(res);
        }
        catch (e) {
            return teamsfx_api_1.err(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message([
                localizeUtils_1.getLocalizedString("error.appstudio.validateFetchSchemaFailed", manifestRes.value.$schema, e.message),
            ])));
        }
    }
    async addAction(copilotGptPath, id, pluginFile) {
        var _a;
        const gptManifestRes = await exports.copilotGptManifestUtils.readCopilotGptManifestFile(copilotGptPath);
        if (gptManifestRes.isErr()) {
            return teamsfx_api_1.err(gptManifestRes.error);
        }
        else {
            const gptManifest = gptManifestRes.value;
            if (!gptManifest.actions) {
                gptManifest.actions = [];
            }
            (_a = gptManifest.actions) === null || _a === void 0 ? void 0 : _a.push({
                id,
                file: pluginFile,
            });
            const updateGptManifestRes = await exports.copilotGptManifestUtils.writeCopilotGptManifestFile(gptManifest, copilotGptPath);
            if (updateGptManifestRes.isErr()) {
                return teamsfx_api_1.err(updateGptManifestRes.error);
            }
            else {
                return teamsfx_api_1.ok(gptManifest);
            }
        }
    }
    logValidationErrors(validationRes, platform, pluginPath) {
        const validationErrors = validationRes.validationResult;
        const filePath = validationRes.filePath;
        let hasError = validationErrors.length > 0;
        for (const actionValidationRes of validationRes.actionValidationResult) {
            if (actionValidationRes.validationResult.length > 0) {
                hasError = true;
                break;
            }
        }
        if (!hasError) {
            return "";
        }
        if (platform !== teamsfx_api_1.Platform.CLI) {
            const errors = validationErrors
                .map((error) => {
                return `${constant_1.SummaryConstant.Failed} ${error}`;
            })
                .join(os_1.EOL);
            let outputMessage = localizeUtils_1.getLocalizedString("driver.teamsApp.summary.validateDeclarativeCopilotManifest.checkPath", filePath) +
                os_1.EOL +
                errors;
            for (const actionValidationRes of validationRes.actionValidationResult) {
                if (pluginPath && actionValidationRes.filePath !== pluginPath) {
                    // do not output validation result of the Declarative Copilot if same file has been validated when validating plugin manifest.
                    const actionValidationMessage = PluginManifestUtils_1.pluginManifestUtils.logValidationErrors(actionValidationRes, platform);
                    if (actionValidationMessage) {
                        outputMessage += os_1.EOL + actionValidationMessage;
                    }
                }
            }
            return outputMessage;
        }
        else {
            const outputMessage = [];
            outputMessage.push({
                content: localizeUtils_1.getDefaultString("driver.teamsApp.summary.validateDeclarativeCopilotManifest.checkPath", filePath) + "\n",
                color: teamsfx_api_1.Colors.BRIGHT_WHITE,
            });
            validationErrors.map((error) => {
                outputMessage.push({ content: `${constant_1.SummaryConstant.Failed} `, color: teamsfx_api_1.Colors.BRIGHT_RED });
                outputMessage.push({
                    content: `${error}\n`,
                    color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                });
            });
            for (const actionValidationRes of validationRes.actionValidationResult) {
                if (pluginPath && actionValidationRes.filePath !== pluginPath) {
                    const actionValidationMessage = PluginManifestUtils_1.pluginManifestUtils.logValidationErrors(actionValidationRes, platform);
                    if (actionValidationMessage) {
                        outputMessage.push(...actionValidationMessage);
                    }
                }
            }
            return outputMessage;
        }
    }
}
exports.CopilotGptManifestUtils = CopilotGptManifestUtils;
exports.copilotGptManifestUtils = new CopilotGptManifestUtils();
//# sourceMappingURL=CopilotGptManifestUtils.js.map