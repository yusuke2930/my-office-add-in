"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var CreateAppPackageDriver_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateAppPackageDriver = exports.actionName = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const typedi_1 = require("typedi");
const localizeUtils_1 = require("../../../common/localizeUtils");
const globalVars_1 = require("../../../core/globalVars");
const common_1 = require("../../../error/common");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const wrapUtil_1 = require("../util/wrapUtil");
const constants_1 = require("./constants");
const ManifestUtils_1 = require("./utils/ManifestUtils");
const telemetry_1 = require("./utils/telemetry");
const teamsApp_1 = require("../../../error/teamsApp");
const utils_1 = require("./utils/utils");
const CopilotGptManifestUtils_1 = require("./utils/CopilotGptManifestUtils");
exports.actionName = "teamsApp/zipAppPackage";
let CreateAppPackageDriver = CreateAppPackageDriver_1 = class CreateAppPackageDriver {
    constructor() {
        this.description = localizeUtils_1.getLocalizedString("driver.teamsApp.description.createAppPackageDriver");
        this.progressTitle = localizeUtils_1.getLocalizedString("plugins.appstudio.createPackage.progressBar.message");
    }
    async execute(args, context) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, exports.actionName, exports.actionName);
        const res = await this.build(args, wrapContext);
        return {
            result: res,
            summaries: wrapContext.summaries,
        };
    }
    async build(args, context) {
        var _a, _b;
        const result = this.validateArgs(args);
        if (result.isErr()) {
            return teamsfx_api_1.err(result.error);
        }
        let manifestPath = args.manifestPath;
        if (!path.isAbsolute(manifestPath)) {
            manifestPath = path.join(context.projectPath, manifestPath);
        }
        const manifestRes = await ManifestUtils_1.manifestUtils.getManifestV3(manifestPath, context);
        if (manifestRes.isErr()) {
            return teamsfx_api_1.err(manifestRes.error);
        }
        const manifest = manifestRes.value;
        // Deal with relative path
        // Environment variables should have been replaced by value
        // ./build/appPackage/appPackage.dev.zip instead of ./build/appPackage/appPackage.${{TEAMSFX_ENV}}.zip
        let zipFileName = args.outputZipPath;
        if (!path.isAbsolute(zipFileName)) {
            zipFileName = path.join(context.projectPath, zipFileName);
        }
        const zipFileDir = path.dirname(zipFileName);
        await fs_extra_1.default.mkdir(zipFileDir, { recursive: true });
        let jsonFileName = args.outputJsonPath;
        if (!path.isAbsolute(jsonFileName)) {
            jsonFileName = path.join(context.projectPath, jsonFileName);
        }
        const jsonFileDir = path.dirname(jsonFileName);
        await fs_extra_1.default.mkdir(jsonFileDir, { recursive: true });
        const appDirectory = path.dirname(manifestPath);
        const colorFile = path.resolve(appDirectory, manifest.icons.color);
        if (!(await fs_extra_1.default.pathExists(colorFile))) {
            const error = new common_1.FileNotFoundError(exports.actionName, colorFile, "https://aka.ms/teamsfx-actions/teamsapp-zipAppPackage");
            return teamsfx_api_1.err(error);
        }
        const colorFileRelativePath = path.relative(appDirectory, colorFile);
        if (colorFileRelativePath.startsWith("..")) {
            return teamsfx_api_1.err(new teamsApp_1.InvalidFileOutsideOfTheDirectotryError(colorFile));
        }
        const outlineFile = path.resolve(appDirectory, manifest.icons.outline);
        if (!(await fs_extra_1.default.pathExists(outlineFile))) {
            const error = new common_1.FileNotFoundError(exports.actionName, outlineFile, "https://aka.ms/teamsfx-actions/teamsapp-zipAppPackage");
            return teamsfx_api_1.err(error);
        }
        const outlineFileRelativePath = path.relative(appDirectory, outlineFile);
        if (outlineFileRelativePath.startsWith("..")) {
            return teamsfx_api_1.err(new teamsApp_1.InvalidFileOutsideOfTheDirectotryError(outlineFile));
        }
        // pre-check existence
        if (manifest.localizationInfo &&
            manifest.localizationInfo.additionalLanguages &&
            manifest.localizationInfo.additionalLanguages.length > 0) {
            for (const language of manifest.localizationInfo.additionalLanguages) {
                const file = language.file;
                const fileName = `${appDirectory}/${file}`;
                if (!(await fs_extra_1.default.pathExists(fileName))) {
                    return teamsfx_api_1.err(new common_1.FileNotFoundError(exports.actionName, fileName, "https://aka.ms/teamsfx-actions/teamsapp-zipAppPackage"));
                }
            }
        }
        const zip = new adm_zip_1.default();
        zip.addFile(constants_1.Constants.MANIFEST_FILE, Buffer.from(JSON.stringify(manifest, null, 4)));
        // outline.png & color.png, relative path
        let dir = path.dirname(manifest.icons.color);
        zip.addLocalFile(colorFile, dir === "." ? "" : dir);
        dir = path.dirname(manifest.icons.outline);
        zip.addLocalFile(outlineFile, dir === "." ? "" : dir);
        // localization file
        if (manifest.localizationInfo &&
            manifest.localizationInfo.additionalLanguages &&
            manifest.localizationInfo.additionalLanguages.length > 0) {
            for (const language of manifest.localizationInfo.additionalLanguages) {
                const file = language.file;
                const fileName = path.resolve(appDirectory, file);
                const relativePath = path.relative(appDirectory, fileName);
                if (relativePath.startsWith("..")) {
                    return teamsfx_api_1.err(new teamsApp_1.InvalidFileOutsideOfTheDirectotryError(fileName));
                }
                const dir = path.dirname(file);
                zip.addLocalFile(fileName, dir === "." ? "" : dir);
            }
        }
        // API ME, API specification and Adaptive card templates
        if (manifest.composeExtensions &&
            manifest.composeExtensions.length > 0 &&
            manifest.composeExtensions[0].composeExtensionType == "apiBased" &&
            manifest.composeExtensions[0].apiSpecificationFile) {
            const apiSpecificationFile = path.resolve(appDirectory, manifest.composeExtensions[0].apiSpecificationFile);
            const checkExistenceRes = await this.validateReferencedFile(apiSpecificationFile, appDirectory);
            if (checkExistenceRes.isErr()) {
                return teamsfx_api_1.err(checkExistenceRes.error);
            }
            const addFileWithVariableRes = await this.addFileWithVariable(zip, manifest.composeExtensions[0].apiSpecificationFile, apiSpecificationFile, telemetry_1.TelemetryPropertyKey.customizedOpenAPIKeys, context);
            if (addFileWithVariableRes.isErr()) {
                return teamsfx_api_1.err(addFileWithVariableRes.error);
            }
            if (manifest.composeExtensions[0].commands.length > 0) {
                for (const command of manifest.composeExtensions[0].commands) {
                    if (command.apiResponseRenderingTemplateFile) {
                        const adaptiveCardFile = path.resolve(appDirectory, command.apiResponseRenderingTemplateFile);
                        const checkExistenceRes = await this.validateReferencedFile(adaptiveCardFile, appDirectory);
                        if (checkExistenceRes.isErr()) {
                            return teamsfx_api_1.err(checkExistenceRes.error);
                        }
                        const dir = path.dirname(command.apiResponseRenderingTemplateFile);
                        this.addFileInZip(zip, dir, adaptiveCardFile);
                    }
                }
            }
        }
        const plugins = (_a = manifest.copilotExtensions) === null || _a === void 0 ? void 0 : _a.plugins;
        // API plugin
        if ((plugins === null || plugins === void 0 ? void 0 : plugins.length) && plugins[0].file) {
            const addFilesRes = await this.addPlugin(zip, plugins[0].file, appDirectory, context);
            if (addFilesRes.isErr()) {
                return teamsfx_api_1.err(addFilesRes.error);
            }
        }
        const declarativeCopilots = (_b = manifest.copilotExtensions) === null || _b === void 0 ? void 0 : _b.declarativeCopilots;
        // Copilot GPT
        if ((declarativeCopilots === null || declarativeCopilots === void 0 ? void 0 : declarativeCopilots.length) && declarativeCopilots[0].file) {
            const copilotGptManifestFile = path.resolve(appDirectory, declarativeCopilots[0].file);
            const checkExistenceRes = await this.validateReferencedFile(copilotGptManifestFile, appDirectory);
            if (checkExistenceRes.isErr()) {
                return teamsfx_api_1.err(checkExistenceRes.error);
            }
            const addFileWithVariableRes = await this.addFileWithVariable(zip, declarativeCopilots[0].file, copilotGptManifestFile, telemetry_1.TelemetryPropertyKey.customizedAIPluginKeys, context);
            if (addFileWithVariableRes.isErr()) {
                return teamsfx_api_1.err(addFileWithVariableRes.error);
            }
            const getCopilotGptRes = await CopilotGptManifestUtils_1.copilotGptManifestUtils.readCopilotGptManifestFile(copilotGptManifestFile);
            if (getCopilotGptRes.isOk()) {
                if (getCopilotGptRes.value.actions) {
                    const pluginFiles = getCopilotGptRes.value.actions.map((action) => action.file);
                    for (const pluginFile of pluginFiles) {
                        const pluginFileAbsolutePath = path.resolve(path.dirname(copilotGptManifestFile), pluginFile);
                        const pluginFileRelativePath = path.relative(appDirectory, pluginFileAbsolutePath);
                        const useForwardSlash = declarativeCopilots[0].file.concat(pluginFile).includes("/");
                        const addPluginRes = await this.addPlugin(zip, utils_1.normalizePath(pluginFileRelativePath, useForwardSlash), appDirectory, context);
                        if (addPluginRes.isErr()) {
                            return teamsfx_api_1.err(addPluginRes.error);
                        }
                    }
                }
            }
            else {
                return teamsfx_api_1.err(getCopilotGptRes.error);
            }
        }
        zip.writeZip(zipFileName);
        if (await fs_extra_1.default.pathExists(jsonFileName)) {
            await fs_extra_1.default.chmod(jsonFileName, 0o777);
        }
        await fs_extra_1.default.writeFile(jsonFileName, JSON.stringify(manifest, null, 4));
        await fs_extra_1.default.chmod(jsonFileName, 0o444);
        const builtSuccess = [
            { content: "(√)Done: ", color: teamsfx_api_1.Colors.BRIGHT_GREEN },
            { content: "Teams Package ", color: teamsfx_api_1.Colors.BRIGHT_WHITE },
            { content: zipFileName, color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
            { content: " built successfully!", color: teamsfx_api_1.Colors.BRIGHT_WHITE },
        ];
        context.logProvider.info(builtSuccess);
        return teamsfx_api_1.ok(new Map());
    }
    static async expandEnvVars(filePath, ctx, telemetryKey) {
        const content = await fs_extra_1.default.readFile(filePath, "utf8");
        return utils_1.getResolvedManifest(content, filePath, telemetryKey, ctx);
    }
    validateArgs(args) {
        const invalidParams = [];
        if (!args || !args.manifestPath) {
            invalidParams.push("manifestPath");
        }
        if (!args || !args.outputJsonPath) {
            invalidParams.push("outputJsonPath");
        }
        if (!args || !args.outputZipPath) {
            invalidParams.push("outputZipPath");
        }
        if (invalidParams.length > 0) {
            return teamsfx_api_1.err(new common_1.InvalidActionInputError(exports.actionName, invalidParams, "https://aka.ms/teamsfx-actions/teamsapp-zipAppPackage"));
        }
        else {
            return teamsfx_api_1.ok(undefined);
        }
    }
    async validateReferencedFile(file, directory) {
        if (!(await fs_extra_1.default.pathExists(file))) {
            return teamsfx_api_1.err(new common_1.FileNotFoundError(exports.actionName, file, "https://aka.ms/teamsfx-actions/teamsapp-zipAppPackage"));
        }
        const relativePath = path.relative(directory, file);
        if (relativePath.startsWith("..")) {
            return teamsfx_api_1.err(new teamsApp_1.InvalidFileOutsideOfTheDirectotryError(file));
        }
        return teamsfx_api_1.ok(undefined);
    }
    /**
     * Add plugin file and plugin related files to zip.
     * @param zip zip
     * @param pluginRelativePath plugin file path relative to app package folder
     * @param appDirectory app package path
     * @param context context
     * @returns result of adding plugin file and plugin related files
     */
    async addPlugin(zip, pluginRelativePath, appDirectory, context) {
        const pluginFile = path.resolve(appDirectory, pluginRelativePath);
        const checkExistenceRes = await this.validateReferencedFile(pluginFile, appDirectory);
        if (checkExistenceRes.isErr()) {
            return teamsfx_api_1.err(checkExistenceRes.error);
        }
        const addFileWithVariableRes = await this.addFileWithVariable(zip, pluginRelativePath, pluginFile, telemetry_1.TelemetryPropertyKey.customizedAIPluginKeys, context);
        if (addFileWithVariableRes.isErr()) {
            return teamsfx_api_1.err(addFileWithVariableRes.error);
        }
        const addFilesRes = await this.addPluginRelatedFiles(zip, pluginRelativePath, appDirectory, context);
        if (addFilesRes.isErr()) {
            return teamsfx_api_1.err(addFilesRes.error);
        }
        else {
            return teamsfx_api_1.ok(undefined);
        }
    }
    /**
     * Add plugin related files (OpenAPI spec) to zip.
     * @param zip zip.
     * @param pluginFile plugin file path relative to app package folder.
     * @param appDirectory app package folder.
     * @param context context.
     * @returns results whether add files related to plugin is successful.
     */
    async addPluginRelatedFiles(zip, pluginFile, appDirectory, context) {
        var _a;
        const pluginFilePath = path.join(appDirectory, pluginFile);
        let pluginContent;
        try {
            pluginContent = (await fs_extra_1.default.readJSON(pluginFilePath));
        }
        catch (e) {
            return teamsfx_api_1.err(new common_1.JSONSyntaxError(pluginFilePath, e, exports.actionName));
        }
        const runtimes = pluginContent.runtimes;
        if (runtimes && runtimes.length > 0) {
            for (const runtime of runtimes) {
                if (runtime.type === "OpenApi" && ((_a = runtime.spec) === null || _a === void 0 ? void 0 : _a.url)) {
                    const specFile = path.resolve(path.dirname(pluginFilePath), runtime.spec.url);
                    // add openapi spec
                    const checkExistenceRes = await this.validateReferencedFile(specFile, appDirectory);
                    if (checkExistenceRes.isErr()) {
                        return teamsfx_api_1.err(checkExistenceRes.error);
                    }
                    const entryName = path.relative(appDirectory, specFile);
                    const useForwardSlash = pluginFile.concat(runtime.spec.url).includes("/");
                    const addFileWithVariableRes = await this.addFileWithVariable(zip, utils_1.normalizePath(entryName, useForwardSlash), specFile, telemetry_1.TelemetryPropertyKey.customizedOpenAPIKeys, context);
                    if (addFileWithVariableRes.isErr()) {
                        return teamsfx_api_1.err(addFileWithVariableRes.error);
                    }
                }
            }
        }
        return teamsfx_api_1.ok(undefined);
    }
    async addFileWithVariable(zip, entryName, filePath, telemetryKey, context) {
        const expandedEnvVarResult = await CreateAppPackageDriver_1.expandEnvVars(filePath, context, telemetryKey);
        if (expandedEnvVarResult.isErr()) {
            return teamsfx_api_1.err(expandedEnvVarResult.error);
        }
        const content = expandedEnvVarResult.value;
        const attr = await fs_extra_1.default.stat(filePath);
        zip.addFile(entryName, Buffer.from(content), "", attr.mode);
        return teamsfx_api_1.ok(undefined);
    }
    addFileInZip(zip, zipPath, filePath) {
        zip.addLocalFile(filePath, zipPath === "." ? "" : zipPath);
    }
};
tslib_1.__decorate([
    lib_1.hooks([
        globalVars_1.ErrorContextMW({ source: "Teams", component: "CreateAppPackageDriver" }),
        addStartAndEndTelemetry_1.addStartAndEndTelemetry(exports.actionName, exports.actionName),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, wrapUtil_1.WrapDriverContext]),
    tslib_1.__metadata("design:returntype", Promise)
], CreateAppPackageDriver.prototype, "build", null);
CreateAppPackageDriver = CreateAppPackageDriver_1 = tslib_1.__decorate([
    typedi_1.Service(exports.actionName)
], CreateAppPackageDriver);
exports.CreateAppPackageDriver = CreateAppPackageDriver;
//# sourceMappingURL=createAppPackage.js.map