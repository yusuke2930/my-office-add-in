"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.getandValidateOauthInfoFromSpec = void 0;
const m365_spec_parser_1 = require("@microsoft/m365-spec-parser");
const common_1 = require("../../../utils/common");
const featureFlags_1 = require("../../../../common/featureFlags");
const lodash_1 = require("lodash");
const constants_1 = require("./constants");
const oauthDomainInvalid_1 = require("../error/oauthDomainInvalid");
const oauthFailedToGetDomain_1 = require("../error/oauthFailedToGetDomain");
const oauthAuthInfoInvalid_1 = require("../error/oauthAuthInfoInvalid");
async function getandValidateOauthInfoFromSpec(args, context, actionName) {
    const absolutePath = common_1.getAbsolutePath(args.apiSpecPath, context.projectPath);
    const parser = new m365_spec_parser_1.SpecParser(absolutePath, {
        allowAPIKeyAuth: false,
        allowBearerTokenAuth: featureFlags_1.isCopilotAuthEnabled(),
        allowMultipleParameters: true,
        allowOauth2: featureFlags_1.isCopilotAuthEnabled(),
        projectType: m365_spec_parser_1.ProjectType.Copilot,
        allowMissingId: true,
        allowSwagger: true,
        allowMethods: ["get", "post", "put", "delete", "patch", "head", "connect", "options", "trace"],
    });
    const listResult = await parser.list();
    const operations = listResult.APIs.filter((value) => value.isValid).filter((value) => {
        const auth = value.auth;
        return auth && auth.authScheme.type === "oauth2" && auth.name === args.name;
    });
    const domains = operations
        .map((value) => {
        return value.server;
    })
        .filter((value, index, self) => {
        return self.indexOf(value) === index;
    });
    validateDomain(domains, actionName);
    if ("flow" in args) {
        const authInfoArray = operations
            .map((value) => {
            var _a;
            let authInfo;
            switch (args.flow) {
                case "authorizationCode":
                default:
                    authInfo = ((_a = value.auth) === null || _a === void 0 ? void 0 : _a.authScheme).flows
                        .authorizationCode;
            }
            return {
                authorizationUrl: authInfo.authorizationUrl,
                tokenUrl: authInfo.tokenUrl,
                refreshUrl: authInfo.refreshUrl,
                scopes: Object.keys(authInfo.scopes),
            };
        })
            .reduce((accumulator, currentValue) => {
            if (!accumulator.find((item) => lodash_1.isEqual(item, currentValue))) {
                accumulator.push(currentValue);
            }
            return accumulator;
        }, []);
        if (authInfoArray.length !== 1) {
            throw new oauthAuthInfoInvalid_1.OauthAuthInfoInvalid(actionName);
        }
        const authInfo = authInfoArray[0];
        return {
            domain: domains,
            authorizationEndpoint: authInfo.authorizationUrl,
            tokenExchangeEndpoint: authInfo.tokenUrl,
            tokenRefreshEndpoint: authInfo.refreshUrl,
            scopes: authInfo.scopes,
        };
    }
    else {
        return {
            domain: domains,
        };
    }
}
exports.getandValidateOauthInfoFromSpec = getandValidateOauthInfoFromSpec;
function validateDomain(domain, actionName) {
    if (domain.length > constants_1.maxDomainPerOauth) {
        throw new oauthDomainInvalid_1.OauthDomainInvalidError(actionName);
    }
    if (domain.length === 0) {
        throw new oauthFailedToGetDomain_1.OauthFailedToGetDomainError(actionName);
    }
}
//# sourceMappingURL=utility.js.map