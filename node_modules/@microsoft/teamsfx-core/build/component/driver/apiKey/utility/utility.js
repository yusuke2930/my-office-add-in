"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateDomain = exports.getDomain = exports.loadStateFromEnv = void 0;
const m365_spec_parser_1 = require("@microsoft/m365-spec-parser");
const common_1 = require("../../../utils/common");
const constants_1 = require("./constants");
const apiKeyDomainInvalid_1 = require("../error/apiKeyDomainInvalid");
const apiKeyFailedToGetDomain_1 = require("../error/apiKeyFailedToGetDomain");
// Needs to validate the parameters outside of the function
function loadStateFromEnv(outputEnvVarNames) {
    const result = {};
    for (const [propertyName, envVarName] of outputEnvVarNames) {
        result[propertyName] = process.env[envVarName];
    }
    return result;
}
exports.loadStateFromEnv = loadStateFromEnv;
// TODO: need to add logic to read domain from env if need to support non-lifecycle commands
async function getDomain(args, context) {
    const absolutePath = common_1.getAbsolutePath(args.apiSpecPath, context.projectPath);
    const parser = new m365_spec_parser_1.SpecParser(absolutePath, {
        allowBearerTokenAuth: true,
        allowMultipleParameters: true,
    });
    const listResult = await parser.list();
    const operations = listResult.APIs.filter((value) => value.isValid);
    const domains = operations
        .filter((value) => {
        const auth = value.auth;
        return (auth &&
            auth.authScheme.type === "http" &&
            auth.authScheme.scheme === "bearer" &&
            auth.name === args.name);
    })
        .map((value) => {
        return value.server;
    })
        .filter((value, index, self) => {
        return self.indexOf(value) === index;
    });
    return domains;
}
exports.getDomain = getDomain;
function validateDomain(domain, actionName) {
    if (domain.length > constants_1.maxDomainPerApiKey) {
        throw new apiKeyDomainInvalid_1.ApiKeyDomainInvalidError(actionName);
    }
    if (domain.length === 0) {
        throw new apiKeyFailedToGetDomain_1.ApiKeyFailedToGetDomainError(actionName);
    }
}
exports.validateDomain = validateDomain;
//# sourceMappingURL=utility.js.map