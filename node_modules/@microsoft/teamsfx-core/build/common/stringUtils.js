"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.maskSecretValues = exports.maskSecret = void 0;
const MIN_ENTROPY = 4;
const SECRET_REPLACE = "<REDACTED:secret>";
const USER_REPLACE = "<REDACTED:user>";
const WHITE_LIST = [
    "user-file-path",
    "publish-app,",
    "X-Correlation-ID",
    "innerError",
    "client-request-id",
];
function getProbMap(str) {
    const probMap = new Map();
    for (const char of str) {
        probMap.set(char, (probMap.get(char) || 0) + 1);
    }
    for (const [char, freq] of probMap.entries()) {
        const prob = freq / str.length;
        probMap.set(char, prob);
    }
    return probMap;
}
// Measure the entropy of a string in bits per symbol.
function shannonEntropy(str, probMap) {
    let sum = 0;
    for (const char of str) {
        const prob = probMap.get(char) || 0;
        const delta = (prob * Math.log(prob)) / Math.log(2);
        sum += delta;
    }
    return -sum;
}
class Token {
    constructor(value, splitter) {
        this.value = value;
        this.splitter = splitter;
    }
}
function tokenize(text) {
    const splitterString = " '`\n\t\r\",:{}";
    const splitterChars = new Set();
    for (const char of splitterString) {
        splitterChars.add(char);
    }
    const tokens = [];
    let currentToken = "";
    for (const char of text) {
        if (splitterChars.has(char)) {
            if (currentToken.length > 0) {
                tokens.push(new Token(currentToken, false));
                currentToken = "";
            }
            tokens.push(new Token(char, true));
        }
        else {
            currentToken += char;
        }
    }
    if (currentToken.length > 0) {
        tokens.push(new Token(currentToken, false));
    }
    return tokens;
}
function computeShannonEntropy(token) {
    if (!token.splitter) {
        const probMap = getProbMap(token.value);
        token.entropy = shannonEntropy(token.value, probMap);
    }
}
function maskSecret(inputText, option = { threshold: MIN_ENTROPY, whiteList: WHITE_LIST }) {
    if (!inputText)
        return "";
    // mask by secret pattern
    inputText = maskByPattern(inputText);
    // mask by .env.xxx.user
    inputText = maskSecretValues(inputText, SECRET_REPLACE);
    // mask by entropy
    let output = "";
    const tokens = tokenize(inputText);
    tokens.forEach((token) => {
        var _a;
        computeShannonEntropy(token);
        if (((_a = option.whiteList) === null || _a === void 0 ? void 0 : _a.includes(token.value)) ||
            token.splitter ||
            (token.entropy || 0) <= option.threshold) {
            output += token.value;
        }
        else {
            output += SECRET_REPLACE;
        }
    });
    // for (const token of tokens) {
    //   console.log(token);
    // }
    return output;
}
exports.maskSecret = maskSecret;
function maskByPattern(command) {
    const regexU = /(-u|--username|--user) (\S+)/;
    const regexP = /(-p|--password|--pwd) (\S+)/;
    let output = command.replace(regexU, `$1 ${USER_REPLACE}`);
    output = output.replace(regexP, `$1 ${SECRET_REPLACE}`);
    return output;
}
function maskSecretValues(stdout, replace = "***") {
    for (const key of Object.keys(process.env)) {
        if (key.startsWith("SECRET_")) {
            const value = process.env[key];
            if (value) {
                stdout = stdout.replace(value, replace);
            }
        }
    }
    return stdout;
}
exports.maskSecretValues = maskSecretValues;
//# sourceMappingURL=stringUtils.js.map